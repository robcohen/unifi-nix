#!/usr/bin/env bash
# unifi-import: Generate Nix configuration from existing UDM setup
set -euo pipefail

HOST="${1:-}"
SSH_USER="${SSH_USER:-root}"

if [[ -z $HOST ]]; then
  echo "Usage: unifi-import <host>"
  echo ""
  echo "Generates a Nix configuration from the current UDM state."
  echo "Output is written to stdout - redirect to a file."
  echo ""
  echo "Environment:"
  echo "  SSH_USER=root  SSH username (default: root)"
  echo ""
  echo "Example:"
  echo "  unifi-import 192.168.1.1 > my-site.nix"
  exit 1
fi

echo "# Importing configuration from $HOST..." >&2

# Fetch all configuration from UDM
CONFIG=$(ssh -o ConnectTimeout=10 "$SSH_USER@$HOST" 'mongo --quiet --port 27117 ace --eval "
JSON.stringify({
  site: db.site.findOne(),
  networks: db.networkconf.find({}).toArray(),
  wifi: db.wlanconf.find({}).toArray(),
  firewallRules: db.traffic_rule.find({}).toArray(),
  firewallPolicies: db.firewall_policy.find({}).toArray(),
  firewallZones: db.firewall_zone.find({}).toArray(),
  portForwards: db.portforward.find({}).toArray(),
  dhcpReservations: db.dhcpd_static.find({}).toArray()
})
"')

# Get network ID to name mapping for lookups
NETWORK_MAP=$(echo "$CONFIG" | jq -c '[.networks[] | {key: (._id["$oid"] // ._id.str // (._id | tostring)), value: .name}] | from_entries')

# Helper to resolve network ID to name
resolve_network() {
  local id="$1"
  echo "$NETWORK_MAP" | jq -r ".[\"$id\"] // \"$id\""
}

# Start generating Nix
cat <<'HEADER'
# UniFi Configuration
# Generated by unifi-import
{
  unifi = {
HEADER

# Host and site
SITE_NAME=$(echo "$CONFIG" | jq -r '.site.name // "default"')
echo "    host = \"$HOST\";"
echo "    site = \"$SITE_NAME\";"
echo ""

# Networks
echo "    # Networks"
echo "    networks = {"

echo "$CONFIG" | jq -r '.networks[] | @base64' | while read -r net_b64; do
  net=$(echo "$net_b64" | base64 -d)

  name=$(echo "$net" | jq -r '.name')
  purpose=$(echo "$net" | jq -r '.purpose // "corporate"')
  subnet=$(echo "$net" | jq -r '.ip_subnet // empty')
  vlan=$(echo "$net" | jq -r '.vlan // 0')
  vlan_enabled=$(echo "$net" | jq -r '.vlan_enabled // false')
  dhcp_enabled=$(echo "$net" | jq -r '.dhcpd_enabled // false')
  dhcp_start=$(echo "$net" | jq -r '.dhcpd_start // empty')
  dhcp_stop=$(echo "$net" | jq -r '.dhcpd_stop // empty')
  dns1=$(echo "$net" | jq -r '.dhcpd_dns_1 // empty')
  dns2=$(echo "$net" | jq -r '.dhcpd_dns_2 // empty')
  isolate=$(echo "$net" | jq -r '.network_isolation_enabled // false')
  mdns=$(echo "$net" | jq -r '.mdns_enabled // true')
  internet=$(echo "$net" | jq -r '.internet_access_enabled // true')
  networkgroup=$(echo "$net" | jq -r '.networkgroup // "LAN"')

  # Skip WAN networks (they don't have subnets typically)
  [[ -z $subnet ]] && continue

  echo "      \"$name\" = {"
  echo "        subnet = \"$subnet\";"

  [[ $purpose != "corporate" ]] && echo "        purpose = \"$purpose\";"
  [[ $networkgroup != "LAN" ]] && echo "        networkGroup = \"$networkgroup\";"
  [[ $vlan_enabled == "true" ]] && [[ $vlan != "0" ]] && echo "        vlan = $vlan;"
  [[ $isolate == "true" ]] && echo "        isolate = true;"
  [[ $mdns == "false" ]] && echo "        mdns = false;"
  [[ $internet == "false" ]] && echo "        internetAccess = false;"

  if [[ $dhcp_enabled == "true" ]]; then
    echo "        dhcp = {"
    echo "          enable = true;"
    [[ -n $dhcp_start ]] && echo "          start = \"$dhcp_start\";"
    [[ -n $dhcp_stop ]] && echo "          end = \"$dhcp_stop\";"

    # DNS servers
    dns_list=""
    [[ -n $dns1 ]] && dns_list="\"$dns1\""
    [[ -n $dns2 ]] && dns_list="$dns_list \"$dns2\""
    [[ -n $dns_list ]] && echo "          dns = [$dns_list ];"

    echo "        };"
  fi

  echo "      };"
  echo ""
done

echo "    };"
echo ""

# WiFi
echo "    # WiFi Networks"
echo "    wifi = {"

echo "$CONFIG" | jq -r '.wifi[] | @base64' | while read -r wifi_b64; do
  wifi=$(echo "$wifi_b64" | base64 -d)

  name=$(echo "$wifi" | jq -r '.name')
  enabled=$(echo "$wifi" | jq -r '.enabled // true')
  networkconf_id=$(echo "$wifi" | jq -r '.networkconf_id // empty')
  hidden=$(echo "$wifi" | jq -r '.hide_ssid // false')
  wpa3=$(echo "$wifi" | jq -r '.wpa3_support // false')
  wpa3_transition=$(echo "$wifi" | jq -r '.wpa3_transition // false')
  pmf=$(echo "$wifi" | jq -r '.pmf_mode // "optional"')
  l2_isolation=$(echo "$wifi" | jq -r '.l2_isolation // false')
  is_guest=$(echo "$wifi" | jq -r '.is_guest // false')
  mcast=$(echo "$wifi" | jq -r '.mcastenhance_enabled // false')
  fast_roaming=$(echo "$wifi" | jq -r '.fast_roaming_enabled // false')
  bss_transition=$(echo "$wifi" | jq -r '.bss_transition // true')

  # Resolve network name
  network_name=""
  if [[ -n $networkconf_id ]]; then
    network_name=$(echo "$NETWORK_MAP" | jq -r ".[\"$networkconf_id\"] // empty")
  fi

  # Generate a safe key name from SSID
  key=$(echo "$name" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/-*$//')

  echo "      \"$key\" = {"
  echo "        ssid = \"$name\";"
  echo "        passphrase = { _secret = \"wifi/$key\"; };"
  [[ -n $network_name ]] && echo "        network = \"$network_name\";"

  [[ $enabled == "false" ]] && echo "        enable = false;"
  [[ $hidden == "true" ]] && echo "        hidden = true;"
  [[ $l2_isolation == "true" ]] && echo "        clientIsolation = true;"
  [[ $is_guest == "true" ]] && echo "        guestMode = true;"
  [[ $mcast == "true" ]] && echo "        multicastEnhance = true;"
  [[ $fast_roaming == "true" ]] && echo "        fastRoaming = true;"
  [[ $bss_transition == "false" ]] && echo "        bssTransition = false;"
  [[ $pmf != "optional" ]] && echo "        pmf = \"$pmf\";"

  if [[ $wpa3 == "true" ]]; then
    echo "        wpa3 = {"
    echo "          enable = true;"
    [[ $wpa3_transition == "true" ]] && echo "          transition = true;"
    echo "        };"
  fi

  echo "      };"
  echo ""
done

echo "    };"
echo ""

# Check if zone-based firewall is enabled
ZONE_COUNT=$(echo "$CONFIG" | jq '.firewallZones | length')
POLICY_COUNT=$(echo "$CONFIG" | jq '.firewallPolicies | length')

if [[ $ZONE_COUNT -gt 0 ]]; then
  # Zone-based firewall (UniFi 10.x+)
  echo "    # Zone-Based Firewall Policies"
  echo "    firewall.policies = {"

  echo "$CONFIG" | jq -r '.firewallPolicies[] | @base64' | while read -r policy_b64; do
    policy=$(echo "$policy_b64" | base64 -d)

    name=$(echo "$policy" | jq -r '.name // empty')
    desc=$(echo "$policy" | jq -r '.description // ""')
    enabled=$(echo "$policy" | jq -r '.enabled // true')
    action=$(echo "$policy" | jq -r '.action // "BLOCK"' | tr '[:upper:]' '[:lower:]')
    protocol=$(echo "$policy" | jq -r '.protocol // "all"')
    ip_version=$(echo "$policy" | jq -r '.ip_version // "BOTH"' | tr '[:upper:]' '[:lower:]')
    index=$(echo "$policy" | jq -r '.index // 10000')
    logging=$(echo "$policy" | jq -r '.logging // false')
    connection_state=$(echo "$policy" | jq -r '.connection_state_type // "ALL"')

    # Source info
    src_zone=$(echo "$policy" | jq -r '.source._zone_key // "internal"')
    src_target=$(echo "$policy" | jq -r '.source.matching_target // "ANY"' | tr '[:upper:]' '[:lower:]')
    src_networks=$(echo "$policy" | jq -r '.source._network_names // [] | .[]' 2>/dev/null || true)
    src_ips=$(echo "$policy" | jq -r '.source._ips // [] | .[]' 2>/dev/null || true)

    # Destination info
    dst_zone=$(echo "$policy" | jq -r '.destination._zone_key // "internal"')
    dst_target=$(echo "$policy" | jq -r '.destination.matching_target // "ANY"' | tr '[:upper:]' '[:lower:]')
    dst_networks=$(echo "$policy" | jq -r '.destination._network_names // [] | .[]' 2>/dev/null || true)
    dst_ips=$(echo "$policy" | jq -r '.destination._ips // [] | .[]' 2>/dev/null || true)
    dst_port=$(echo "$policy" | jq -r 'if .destination.ports and (.destination.ports | length) > 0 then .destination.ports[0] else empty end' 2>/dev/null || true)

    [[ -z $name ]] && continue

    # Generate key from name
    key=$(echo "$name" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/-*$//' | cut -c1-40)

    echo "      \"$key\" = {"
    echo "        name = \"$name\";"
    [[ -n $desc ]] && echo "        description = \"$desc\";"
    echo "        action = \"$action\";"
    echo "        sourceZone = \"$src_zone\";"
    echo "        destinationZone = \"$dst_zone\";"

    # Source type and networks/IPs
    if [[ $src_target == "network" ]] && [[ -n $src_networks ]]; then
      echo '        sourceType = "network";'
      networks_nix=$(echo "$src_networks" | xargs -I{} echo -n '"{}" ' | sed 's/ $//')
      echo "        sourceNetworks = [ $networks_nix ];"
    elif [[ $src_target == "ip" ]] && [[ -n $src_ips ]]; then
      echo '        sourceType = "ip";'
      ips_nix=$(echo "$src_ips" | xargs -I{} echo -n '"{}" ' | sed 's/ $//')
      echo "        sourceIPs = [ $ips_nix ];"
    fi

    # Destination type and networks/IPs
    if [[ $dst_target == "network" ]] && [[ -n $dst_networks ]]; then
      echo '        destinationType = "network";'
      networks_nix=$(echo "$dst_networks" | xargs -I{} echo -n '"{}" ' | sed 's/ $//')
      echo "        destinationNetworks = [ $networks_nix ];"
    elif [[ $dst_target == "ip" ]] && [[ -n $dst_ips ]]; then
      echo '        destinationType = "ip";'
      ips_nix=$(echo "$dst_ips" | xargs -I{} echo -n '"{}" ' | sed 's/ $//')
      echo "        destinationIPs = [ $ips_nix ];"
    fi

    [[ -n $dst_port ]] && echo "        destinationPort = $dst_port;"
    [[ $protocol != "all" ]] && echo "        protocol = \"$protocol\";"
    [[ $ip_version != "both" ]] && echo "        ipVersion = \"$ip_version\";"
    [[ $connection_state != "ALL" ]] && echo "        connectionState = \"$connection_state\";"
    [[ $enabled == "false" ]] && echo "        enable = false;"
    [[ $logging == "true" ]] && echo "        logging = true;"
    [[ $index != "10000" ]] && echo "        index = $index;"

    echo "      };"
    echo ""
  done

  echo "    };"
else
  # Legacy traffic rules (deprecated)
  RULE_COUNT=$(echo "$CONFIG" | jq '.firewallRules | length')
  if [[ $RULE_COUNT -gt 0 ]]; then
    echo "    # Legacy Firewall Rules (DEPRECATED - upgrade to zone-based firewall)"
    echo "    # firewall.rules = {"
    echo "$CONFIG" | jq -r '.firewallRules[] | "    #   \(.description // "unnamed"): \(.action // "drop")"'
    echo "    # };"
    echo ""
    echo "    # NOTE: Zone-based firewall is not enabled on this device."
    echo "    # Enable it in UniFi Settings > Firewall & Security > Upgrade to Zone-Based Firewall"
    echo "    # Then re-run this import to get proper firewall.policies configuration."
  fi
fi

# Port Forwards
port_forward_count=$(echo "$CONFIG" | jq '.portForwards | length')
if [[ $port_forward_count -gt 0 ]]; then
  echo ""
  echo "    # Port Forwards"
  echo "    portForwards = {"

  echo "$CONFIG" | jq -r '.portForwards[] | @base64' | while read -r pf_b64; do
    pf=$(echo "$pf_b64" | base64 -d)

    name=$(echo "$pf" | jq -r '.name // empty')
    enabled=$(echo "$pf" | jq -r '.enabled // true')
    proto=$(echo "$pf" | jq -r '.proto // "tcp_udp"')
    src_port=$(echo "$pf" | jq -r '.dst_port // empty')
    dst_ip=$(echo "$pf" | jq -r '.fwd // empty')
    dst_port=$(echo "$pf" | jq -r '.fwd_port // empty')
    src_ip=$(echo "$pf" | jq -r '.src // empty')
    log=$(echo "$pf" | jq -r '.log // false')

    [[ -z $dst_ip ]] && continue
    [[ -z $src_port ]] && continue

    # Generate key from name or port
    if [[ -n $name ]]; then
      key=$(echo "$name" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/-*$//' | cut -c1-40)
    else
      key="port-$src_port"
    fi

    echo "      \"$key\" = {"
    [[ -n $name ]] && echo "        name = \"$name\";"
    echo "        srcPort = $src_port;"
    echo "        dstIP = \"$dst_ip\";"
    [[ -n $dst_port ]] && [[ $dst_port != "$src_port" ]] && echo "        dstPort = $dst_port;"
    [[ $proto != "tcp_udp" ]] && echo "        protocol = \"$proto\";"
    [[ -n $src_ip ]] && [[ $src_ip != "any" ]] && echo "        srcIP = \"$src_ip\";"
    [[ $enabled == "false" ]] && echo "        enable = false;"
    [[ $log == "true" ]] && echo "        log = true;"
    echo "      };"
    echo ""
  done

  echo "    };"
fi

# DHCP Reservations
dhcp_count=$(echo "$CONFIG" | jq '.dhcpReservations | length')
if [[ $dhcp_count -gt 0 ]]; then
  echo ""
  echo "    # DHCP Reservations"
  echo "    dhcpReservations = {"

  echo "$CONFIG" | jq -r '.dhcpReservations[] | @base64' | while read -r dhcp_b64; do
    dhcp=$(echo "$dhcp_b64" | base64 -d)

    mac=$(echo "$dhcp" | jq -r '.mac // empty')
    ip=$(echo "$dhcp" | jq -r '.ip // empty')
    hostname=$(echo "$dhcp" | jq -r '.name // empty')
    network_id=$(echo "$dhcp" | jq -r '.network_id // empty')

    [[ -z $mac ]] && continue
    [[ -z $ip ]] && continue

    # Resolve network name
    network_name=""
    if [[ -n $network_id ]]; then
      network_name=$(echo "$NETWORK_MAP" | jq -r ".[\"$network_id\"] // empty")
    fi

    # Generate key from hostname or MAC
    if [[ -n $hostname ]]; then
      key=$(echo "$hostname" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/-*$//' | cut -c1-40)
    else
      key=$(echo "$mac" | tr ':' '-' | tr '[:upper:]' '[:lower:]')
    fi

    echo "      \"$key\" = {"
    echo "        mac = \"$mac\";"
    echo "        ip = \"$ip\";"
    [[ -n $hostname ]] && echo "        name = \"$hostname\";"
    [[ -n $network_name ]] && echo "        network = \"$network_name\";"
    echo "      };"
    echo ""
  done

  echo "    };"
fi

cat <<'FOOTER'
  };
}
FOOTER

echo "" >&2
echo "# Import complete. Review the output and adjust as needed." >&2
echo "# WiFi passphrases are set to secrets - configure your secret management." >&2
