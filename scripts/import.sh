#!/usr/bin/env bash
# unifi-import: Generate Nix configuration from existing UDM setup
set -euo pipefail

HOST="${1:-}"
SSH_USER="${SSH_USER:-root}"

if [[ -z "$HOST" ]]; then
  echo "Usage: unifi-import <host>"
  echo ""
  echo "Generates a Nix configuration from the current UDM state."
  echo "Output is written to stdout - redirect to a file."
  echo ""
  echo "Environment:"
  echo "  SSH_USER=root  SSH username (default: root)"
  echo ""
  echo "Example:"
  echo "  unifi-import 192.168.1.1 > my-site.nix"
  exit 1
fi

echo "# Importing configuration from $HOST..." >&2

# Fetch all configuration from UDM
CONFIG=$(ssh -o ConnectTimeout=10 "$SSH_USER@$HOST" 'mongo --quiet --port 27117 ace --eval "
JSON.stringify({
  site: db.site.findOne(),
  networks: db.networkconf.find({}).toArray(),
  wifi: db.wlanconf.find({}).toArray(),
  firewallRules: db.traffic_rule.find({}).toArray(),
  portForwards: db.portforward.find({}).toArray(),
  dhcpReservations: db.dhcp_option.find({}).toArray()
})
"')

# Get network ID to name mapping for lookups
NETWORK_MAP=$(echo "$CONFIG" | jq -c '[.networks[] | {key: (._id["$oid"] // ._id.str // (._id | tostring)), value: .name}] | from_entries')

# Helper to resolve network ID to name
resolve_network() {
  local id="$1"
  echo "$NETWORK_MAP" | jq -r ".[\"$id\"] // \"$id\""
}

# Start generating Nix
cat << 'HEADER'
# UniFi Configuration
# Generated by unifi-import
{
  unifi = {
HEADER

# Host and site
SITE_NAME=$(echo "$CONFIG" | jq -r '.site.name // "default"')
echo "    host = \"$HOST\";"
echo "    site = \"$SITE_NAME\";"
echo ""

# Networks
echo "    # Networks"
echo "    networks = {"

echo "$CONFIG" | jq -r '.networks[] | @base64' | while read -r net_b64; do
  net=$(echo "$net_b64" | base64 -d)

  name=$(echo "$net" | jq -r '.name')
  purpose=$(echo "$net" | jq -r '.purpose // "corporate"')
  subnet=$(echo "$net" | jq -r '.ip_subnet // empty')
  vlan=$(echo "$net" | jq -r '.vlan // 0')
  vlan_enabled=$(echo "$net" | jq -r '.vlan_enabled // false')
  dhcp_enabled=$(echo "$net" | jq -r '.dhcpd_enabled // false')
  dhcp_start=$(echo "$net" | jq -r '.dhcpd_start // empty')
  dhcp_stop=$(echo "$net" | jq -r '.dhcpd_stop // empty')
  dns1=$(echo "$net" | jq -r '.dhcpd_dns_1 // empty')
  dns2=$(echo "$net" | jq -r '.dhcpd_dns_2 // empty')
  isolate=$(echo "$net" | jq -r '.network_isolation_enabled // false')
  mdns=$(echo "$net" | jq -r '.mdns_enabled // true')
  internet=$(echo "$net" | jq -r '.internet_access_enabled // true')
  networkgroup=$(echo "$net" | jq -r '.networkgroup // "LAN"')

  # Skip WAN networks (they don't have subnets typically)
  [[ -z "$subnet" ]] && continue

  echo "      \"$name\" = {"
  echo "        subnet = \"$subnet\";"

  [[ "$purpose" != "corporate" ]] && echo "        purpose = \"$purpose\";"
  [[ "$networkgroup" != "LAN" ]] && echo "        networkGroup = \"$networkgroup\";"
  [[ "$vlan_enabled" == "true" ]] && [[ "$vlan" != "0" ]] && echo "        vlan = $vlan;"
  [[ "$isolate" == "true" ]] && echo "        isolate = true;"
  [[ "$mdns" == "false" ]] && echo "        mdns = false;"
  [[ "$internet" == "false" ]] && echo "        internetAccess = false;"

  if [[ "$dhcp_enabled" == "true" ]]; then
    echo "        dhcp = {"
    echo "          enable = true;"
    [[ -n "$dhcp_start" ]] && echo "          start = \"$dhcp_start\";"
    [[ -n "$dhcp_stop" ]] && echo "          end = \"$dhcp_stop\";"

    # DNS servers
    dns_list=""
    [[ -n "$dns1" ]] && dns_list="\"$dns1\""
    [[ -n "$dns2" ]] && dns_list="$dns_list \"$dns2\""
    [[ -n "$dns_list" ]] && echo "          dns = [$dns_list ];"

    echo "        };"
  fi

  echo "      };"
  echo ""
done

echo "    };"
echo ""

# WiFi
echo "    # WiFi Networks"
echo "    wifi = {"

echo "$CONFIG" | jq -r '.wifi[] | @base64' | while read -r wifi_b64; do
  wifi=$(echo "$wifi_b64" | base64 -d)

  name=$(echo "$wifi" | jq -r '.name')
  enabled=$(echo "$wifi" | jq -r '.enabled // true')
  networkconf_id=$(echo "$wifi" | jq -r '.networkconf_id // empty')
  hidden=$(echo "$wifi" | jq -r '.hide_ssid // false')
  wpa3=$(echo "$wifi" | jq -r '.wpa3_support // false')
  wpa3_transition=$(echo "$wifi" | jq -r '.wpa3_transition // false')
  pmf=$(echo "$wifi" | jq -r '.pmf_mode // "optional"')
  l2_isolation=$(echo "$wifi" | jq -r '.l2_isolation // false')
  is_guest=$(echo "$wifi" | jq -r '.is_guest // false')
  mcast=$(echo "$wifi" | jq -r '.mcastenhance_enabled // false')
  fast_roaming=$(echo "$wifi" | jq -r '.fast_roaming_enabled // false')
  bss_transition=$(echo "$wifi" | jq -r '.bss_transition // true')

  # Resolve network name
  network_name=""
  if [[ -n "$networkconf_id" ]]; then
    network_name=$(echo "$NETWORK_MAP" | jq -r ".[\"$networkconf_id\"] // empty")
  fi

  # Generate a safe key name from SSID
  key=$(echo "$name" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/-*$//')

  echo "      \"$key\" = {"
  echo "        ssid = \"$name\";"
  echo "        passphrase = { _secret = \"wifi/$key\"; };"
  [[ -n "$network_name" ]] && echo "        network = \"$network_name\";"

  [[ "$enabled" == "false" ]] && echo "        enable = false;"
  [[ "$hidden" == "true" ]] && echo "        hidden = true;"
  [[ "$l2_isolation" == "true" ]] && echo "        clientIsolation = true;"
  [[ "$is_guest" == "true" ]] && echo "        guestMode = true;"
  [[ "$mcast" == "true" ]] && echo "        multicastEnhance = true;"
  [[ "$fast_roaming" == "true" ]] && echo "        fastRoaming = true;"
  [[ "$bss_transition" == "false" ]] && echo "        bssTransition = false;"
  [[ "$pmf" != "optional" ]] && echo "        pmf = \"$pmf\";"

  if [[ "$wpa3" == "true" ]]; then
    echo "        wpa3 = {"
    echo "          enable = true;"
    [[ "$wpa3_transition" == "true" ]] && echo "          transition = true;"
    echo "        };"
  fi

  echo "      };"
  echo ""
done

echo "    };"
echo ""

# Firewall Rules
echo "    # Firewall Rules"
echo "    firewall.rules = {"

echo "$CONFIG" | jq -r '.firewallRules[] | @base64' | while read -r rule_b64; do
  rule=$(echo "$rule_b64" | base64 -d)

  desc=$(echo "$rule" | jq -r '.description // empty')
  enabled=$(echo "$rule" | jq -r '.enabled // true')
  action=$(echo "$rule" | jq -r '.action // "drop"')
  protocol=$(echo "$rule" | jq -r '.ip_protocol // "all"')
  dst_port=$(echo "$rule" | jq -r '.dst_port // empty')
  index=$(echo "$rule" | jq -r '.index // 2000')

  [[ -z "$desc" ]] && continue

  # Generate key from description
  key=$(echo "$desc" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/-*$//' | cut -c1-40)

  echo "      \"$key\" = {"
  echo "        description = \"$desc\";"
  echo "        action = \"$action\";"
  echo "        from = \"any\";  # TODO: resolve from rule"
  echo "        to = \"any\";    # TODO: resolve from rule"
  [[ "$enabled" == "false" ]] && echo "        enable = false;"
  [[ "$protocol" != "all" ]] && echo "        protocol = \"$protocol\";"
  [[ -n "$dst_port" ]] && echo "        ports = [ $dst_port ];"
  [[ "$index" != "2000" ]] && echo "        index = $index;"
  echo "      };"
  echo ""
done

echo "    };"

# Port Forwards
port_forward_count=$(echo "$CONFIG" | jq '.portForwards | length')
if [[ "$port_forward_count" -gt 0 ]]; then
  echo ""
  echo "    # Port Forwards (not yet supported - showing for reference)"
  echo "    # portForwards = {"
  echo "$CONFIG" | jq -r '.portForwards[] | "    #   \(.name // .dst_port): \(.src // "any"):\(.dst_port) -> \(.fwd):\(.fwd_port)"'
  echo "    # };"
fi

# DHCP Reservations
dhcp_count=$(echo "$CONFIG" | jq '.dhcpReservations | length')
if [[ "$dhcp_count" -gt 0 ]]; then
  echo ""
  echo "    # DHCP Reservations (not yet supported - showing for reference)"
  echo "    # dhcpReservations = {"
  echo "$CONFIG" | jq -r '.dhcpReservations[] | "    #   \(.mac): \(.ip)"'
  echo "    # };"
fi

cat << 'FOOTER'
  };
}
FOOTER

echo "" >&2
echo "# Import complete. Review the output and adjust as needed." >&2
echo "# WiFi passphrases are set to secrets - configure your secret management." >&2
