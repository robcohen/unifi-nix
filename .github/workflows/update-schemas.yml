name: Update UniFi Schemas
on:
  schedule:
    # Run weekly on Sunday at midnight
    - cron: "0 0 * * 0"
  workflow_dispatch:
    inputs:
      force:
        description: "Force extraction even if version exists"
        required: false
        default: "false"
      version:
        description: "Specific version to extract (leave empty for latest)"
        required: false
        default: ""
permissions:
  contents: write
env:
  MONGO_USER: unifi
  MONGO_PASS: unifi
jobs:
  extract-schemas:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      needs_update: ${{ steps.check-version.outputs.needs_extraction }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      - name: Check for new UniFi version
        id: check-version
        run: |
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            LATEST_TAG="${{ github.event.inputs.version }}"
            echo "Using specified version: $LATEST_TAG"
          else
            # Get latest version from Docker Hub
            LATEST_TAG=$(curl -s "https://hub.docker.com/v2/repositories/linuxserver/unifi-network-application/tags?page_size=100" | \
              jq -r '.results[].name' | \
              grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | \
              sort -V | \
              tail -1)
            echo "Latest Docker tag: $LATEST_TAG"
          fi

          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # Check if we already have this version
          if [[ -d "schemas/$LATEST_TAG" ]] && [[ "${{ github.event.inputs.force }}" != "true" ]]; then
            echo "Schema for version $LATEST_TAG already exists"
            echo "needs_extraction=false" >> $GITHUB_OUTPUT
          else
            echo "New version detected or force extraction requested"
            echo "needs_extraction=true" >> $GITHUB_OUTPUT
          fi
      - name: Create Docker network
        if: steps.check-version.outputs.needs_extraction == 'true'
        run: docker network create unifi-extract
      - name: Start MongoDB
        if: steps.check-version.outputs.needs_extraction == 'true'
        run: |
          docker run -d --name mongo \
            --network unifi-extract \
            -e MONGO_INITDB_ROOT_USERNAME=$MONGO_USER \
            -e MONGO_INITDB_ROOT_PASSWORD=$MONGO_PASS \
            -p 27017:27017 \
            mongo:7.0

          echo "Waiting for MongoDB to be ready..."
          for i in {1..30}; do
            if docker exec mongo mongosh --eval "db.adminCommand('ping')" &>/dev/null; then
              echo "MongoDB ping successful"
              break
            fi
            sleep 2
          done

          # Wait for authentication to be ready (root user created)
          echo "Waiting for MongoDB authentication..."
          for i in {1..30}; do
            if docker exec mongo mongosh -u $MONGO_USER -p $MONGO_PASS --authenticationDatabase admin --eval "db.adminCommand('ping')" &>/dev/null; then
              echo "MongoDB authentication ready"
              break
            fi
            echo "  Auth not ready yet, waiting... ($i)"
            sleep 2
          done
      - name: Initialize MongoDB for UniFi
        if: steps.check-version.outputs.needs_extraction == 'true'
        run: |
          docker exec mongo mongosh -u $MONGO_USER -p $MONGO_PASS --authenticationDatabase admin --eval '
            db = db.getSiblingDB("unifi");
            db.createUser({
              user: "unifi",
              pwd: "unifi",
              roles: [
                { role: "dbOwner", db: "unifi" },
                { role: "readWrite", db: "unifi" }
              ]
            });
            db = db.getSiblingDB("unifi_stat");
            db.createUser({
              user: "unifi",
              pwd: "unifi",
              roles: [
                { role: "dbOwner", db: "unifi_stat" },
                { role: "readWrite", db: "unifi_stat" }
              ]
            });
          '
      - name: Start UniFi Network Application
        if: steps.check-version.outputs.needs_extraction == 'true'
        run: |
          VERSION="${{ steps.check-version.outputs.latest_tag }}"

          docker run -d --name unifi \
            --network unifi-extract \
            -e PUID=1000 \
            -e PGID=1000 \
            -e TZ=UTC \
            -e MONGO_USER=unifi \
            -e MONGO_PASS=unifi \
            -e MONGO_HOST=mongo \
            -e MONGO_PORT=27017 \
            -e MONGO_DBNAME=unifi \
            -e MONGO_AUTHSOURCE=admin \
            -e MEM_LIMIT=512 \
            -p 8443:8443 \
            -p 8080:8080 \
            "lscr.io/linuxserver/unifi-network-application:${VERSION}"

          echo "Waiting for UniFi to initialize (this may take 3-5 minutes)..."

          MAX_WAIT=300
          WAITED=0
          while [[ $WAITED -lt $MAX_WAIT ]]; do
            # Check if site collection exists (indicates initialization complete)
            if docker exec mongo mongosh -u unifi -p unifi --authenticationDatabase admin unifi \
              --quiet --eval "db.site.countDocuments()" 2>/dev/null | grep -q "^[0-9]"; then
              echo "UniFi initialized!"
              break
            fi
            sleep 10
            WAITED=$((WAITED + 10))
            echo "  Waiting... ($WAITED seconds)"
          done

          if [[ $WAITED -ge $MAX_WAIT ]]; then
            echo "ERROR: Timeout waiting for UniFi initialization"
            docker logs unifi | tail -100
            exit 1
          fi

          # Additional wait for API to be ready
          sleep 30
      - name: Extract schemas
        if: steps.check-version.outputs.needs_extraction == 'true'
        id: extract
        run: |
          # Detect version from MongoDB
          DETECTED_VERSION=$(docker exec mongo mongosh -u unifi -p unifi --authenticationDatabase admin unifi \
            --quiet --eval "db.version_history.find().sort({_id:-1}).limit(1).toArray()[0]?.version || 'unknown'" 2>/dev/null | tr -d '"' || echo "unknown")

          if [[ $DETECTED_VERSION == "unknown" ]]; then
            DETECTED_VERSION="${{ steps.check-version.outputs.latest_tag }}"
          fi
          echo "Detected version: $DETECTED_VERSION"
          echo "version=$DETECTED_VERSION" >> $GITHUB_OUTPUT

          SCHEMA_DIR="schemas/$DETECTED_VERSION"
          mkdir -p "$SCHEMA_DIR"

          # 1. Extract field definitions from core.jar (authoritative source of enums/validation)
          echo "Extracting field definitions from core.jar..."
          docker cp unifi:/usr/lib/unifi/lib/internal/core.jar "$SCHEMA_DIR/core.jar"
          if [[ -f "$SCHEMA_DIR/core.jar" ]]; then
            # Extract api/fields/*.json from the JAR
            mkdir -p "$SCHEMA_DIR/jar-fields"
            unzip -q -o "$SCHEMA_DIR/core.jar" "api/fields/*" -d "$SCHEMA_DIR/jar-extract" 2>/dev/null || true
            if [[ -d "$SCHEMA_DIR/jar-extract/api/fields" ]]; then
              mv "$SCHEMA_DIR/jar-extract/api/fields/"*.json "$SCHEMA_DIR/jar-fields/"
              echo "  Extracted $(ls "$SCHEMA_DIR/jar-fields/" | wc -l) field definition files"
            else
              echo "  Warning: Could not extract api/fields from core.jar"
            fi
            rm -rf "$SCHEMA_DIR/jar-extract" "$SCHEMA_DIR/core.jar"
          else
            echo "  Warning: Could not copy core.jar from container"
          fi

          # 2. Extract MongoDB collections list
          echo "Extracting collection list..."
          docker exec mongo mongosh -u unifi -p unifi --authenticationDatabase admin unifi \
            --quiet --eval "JSON.stringify(db.getCollectionNames())" > "$SCHEMA_DIR/collections.json"

          # 3. Extract field schemas
          echo "Extracting field schemas..."
          docker exec mongo mongosh -u unifi -p unifi --authenticationDatabase admin unifi \
            --quiet --eval '
          var collections = db.getCollectionNames();
          var schemas = {};
          collections.forEach(function(coll) {
            if (coll.startsWith("system.")) return;
            var fields = [];
            var sample = db[coll].findOne();
            if (sample) {
              Object.keys(sample).forEach(function(key) {
                fields.push(key);
              });
            }
            if (fields.length > 0) {
              schemas[coll] = fields;
            }
          });
          JSON.stringify(schemas, null, 2);
          ' > "$SCHEMA_DIR/mongodb-fields.json"

          # 4. Extract example documents
          echo "Extracting example documents..."
          docker exec mongo mongosh -u unifi -p unifi --authenticationDatabase admin unifi \
            --quiet --eval '
          var keyCollections = [
            "networkconf", "wlanconf", "portforward", "firewall_policy", "firewall_zone",
            "firewallgroup", "traffic_rule", "radiusprofile", "portconf", "apgroup",
            "usergroup", "dpigroup", "scheduletask", "wlangroup", "dhcp_option",
            "setting", "site", "device"
          ];
          var examples = {};
          keyCollections.forEach(function(coll) {
            var doc = db[coll].findOne();
            if (doc) {
              delete doc.x_passphrase;
              delete doc.x_password;
              delete doc.x_psk;
              delete doc.x_secret;
              examples[coll] = doc;
            }
          });
          JSON.stringify(examples, null, 2);
          ' > "$SCHEMA_DIR/mongodb-examples.json"

          # 5. Extract enums from MongoDB data
          echo "Extracting enums from data..."
          docker exec mongo mongosh -u unifi -p unifi --authenticationDatabase admin unifi \
            --quiet --eval '
          var enums = {
            zone_keys: db.firewall_zone.distinct("zone_key").filter(x => x),
            network_purposes: db.networkconf.distinct("purpose").filter(x => x),
            network_groups: db.networkconf.distinct("networkgroup").filter(x => x),
            wifi_security: db.wlanconf.distinct("security").filter(x => x),
            wifi_wpa_modes: db.wlanconf.distinct("wpa_mode").filter(x => x),
            wifi_pmf_modes: db.wlanconf.distinct("pmf_mode").filter(x => x),
            policy_actions: db.firewall_policy.distinct("action").filter(x => x),
            setting_keys: db.setting.distinct("key").filter(x => x)
          };
          JSON.stringify(enums, null, 2);
          ' > "$SCHEMA_DIR/enums.json"

          # 6. Extract collection stats
          echo "Extracting statistics..."
          docker exec mongo mongosh -u unifi -p unifi --authenticationDatabase admin unifi \
            --quiet --eval '
          var stats = db.getCollectionNames()
            .filter(c => !c.startsWith("system."))
            .map(c => ({ name: c, count: db[c].countDocuments() }))
            .filter(s => s.count > 0)
            .sort((a,b) => b.count - a.count);
          JSON.stringify(stats, null, 2);
          ' > "$SCHEMA_DIR/mongodb-stats.json"

          # 7. Save version
          echo "$DETECTED_VERSION" > "$SCHEMA_DIR/version"

          echo "schema_dir=$SCHEMA_DIR" >> $GITHUB_OUTPUT
          echo "Schema extraction complete!"
          ls -la "$SCHEMA_DIR"
      - name: Cleanup containers
        if: always() && steps.check-version.outputs.needs_extraction == 'true'
        run: |
          docker rm -f unifi mongo || true
          docker network rm unifi-extract || true
      - name: Upload schema artifacts
        if: steps.check-version.outputs.needs_extraction == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: schemas-${{ steps.extract.outputs.version }}
          path: schemas/${{ steps.extract.outputs.version }}
  generate-from-schemas:
    needs: extract-schemas
    if: needs.extract-schemas.outputs.needs_update == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Download schema artifacts
        uses: actions/download-artifact@v4
        with:
          name: schemas-${{ needs.extract-schemas.outputs.version }}
          path: schemas/${{ needs.extract-schemas.outputs.version }}
      - name: Install Nix
        uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-24.11
          extra_nix_config: |
            experimental-features = nix-command flakes
      - name: Run generators
        run: |
          VERSION="${{ needs.extract-schemas.outputs.version }}"
          SCHEMA_DIR="schemas/$VERSION"

          echo "Running generators for version $VERSION..."
          echo "Schema files present:"
          ls -la "$SCHEMA_DIR/" || echo "No schema dir yet"

          # Run generators directly (the Nix derivation expects schemas in flake source)
          mkdir -p "$SCHEMA_DIR/generated"

          # Extract enums and validation from JAR field definitions (authoritative source)
          if [[ -d "$SCHEMA_DIR/jar-fields" ]] && [[ -n "$(ls -A "$SCHEMA_DIR/jar-fields" 2>/dev/null)" ]]; then
            echo "Extracting enums from JAR field definitions..."
            nix-shell -p jq unzip --run "bash scripts/generators/extract-from-jar.sh '$SCHEMA_DIR' '$SCHEMA_DIR/generated'" || echo "Warning: JAR extraction failed"
          else
            echo "Warning: No JAR field definitions found, using empty enums"
            echo "{}" > "$SCHEMA_DIR/generated/enums.json"
            echo "{}" > "$SCHEMA_DIR/generated/validation.json"
          fi

          # extract-defaults.sh expects: <mongodb-examples.json> <output.json>
          nix-shell -p jq --run "bash scripts/generators/extract-defaults.sh '$SCHEMA_DIR/mongodb-examples.json' '$SCHEMA_DIR/generated/defaults.json'" || echo "Warning: defaults extraction failed"

          # generate-json-schema.sh expects: <fields.json> <examples.json> <enums.json> <output-dir>
          nix-shell -p jq --run "bash scripts/generators/generate-json-schema.sh '$SCHEMA_DIR/mongodb-fields.json' '$SCHEMA_DIR/mongodb-examples.json' '$SCHEMA_DIR/generated/enums.json' '$SCHEMA_DIR/generated/json-schema'" || echo "Warning: JSON schema generation failed"

          echo "Generated files:"
          ls -la "$SCHEMA_DIR/generated/" || echo "No generated files"

          if [[ -d "$SCHEMA_DIR/generated/json-schema" ]]; then
            echo "JSON schemas:"
            ls "$SCHEMA_DIR/generated/json-schema/" | head -10
          fi
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          VERSION="${{ needs.extract-schemas.outputs.version }}"

          git add schemas/
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update schemas for UniFi $VERSION

          Automatically extracted and generated:
          - Field definitions from core.jar (api/fields/)
          - MongoDB collection schemas and examples
          - 280+ enum types and validation patterns
          - JSON schemas for all collections

          ðŸ¤– Generated by GitHub Actions"

            git push
          fi
      - name: Create summary
        run: |
          VERSION="${{ needs.extract-schemas.outputs.version }}"
          SCHEMA_DIR="schemas/$VERSION"

          echo "## Schema Update Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Extracted Files" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ls -la "$SCHEMA_DIR" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ -d "$SCHEMA_DIR/generated" ]]; then
            echo "### Generated Files" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            ls -la "$SCHEMA_DIR/generated" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [[ -f "$SCHEMA_DIR/generated/enums.json" ]]; then
              ENUM_COUNT=$(jq 'keys | length' "$SCHEMA_DIR/generated/enums.json")
              echo "**Enums extracted:** $ENUM_COUNT types" >> $GITHUB_STEP_SUMMARY
            fi

            if [[ -d "$SCHEMA_DIR/generated/json-schema" ]]; then
              SCHEMA_COUNT=$(ls "$SCHEMA_DIR/generated/json-schema"/*.schema.json 2>/dev/null | wc -l)
              echo "**JSON schemas generated:** $SCHEMA_COUNT" >> $GITHUB_STEP_SUMMARY
            fi
          fi
